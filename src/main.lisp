(in-package :dezero)

(let ((a (mgl-mat:make-mat '(2 2)
			   :initial-contents '((5 2)
					       (7 3))))
      (b (mgl-mat:make-mat '(2 2)
			   :initial-contents '((0 3)
					       (5 9))))
      (c (mgl-mat:make-mat '(2 2) :initial-element 0)))
  (mgl-mat:gemm! 2 a b 0 c))

(let* ((x (make-instance 'variable
			 :data (mgl-mat:make-mat '(2 2)
						 :initial-element 2)))
       (f (make-instance 'square))
       (y (call f x)))
  (slot-value y 'data))

(let ((x (mgl-mat:make-mat '(1 1) :initial-element 0.5))
      (y (mgl-mat:make-mat '(1 1))))
  (mgl-mat:gemm! 1 x x 0 y))

(let* ((af (make-instance 'square))
       (x (make-instance 'variable
			 :data (mgl-mat:make-mat '(1 1)
						 :initial-element 0.5)))
       (a (call af x)))
  (slot-value a 'data))

(let* ((af (make-instance 'square))
       (bf (make-instance 'exp))
       (cf (make-instance 'square))
       (x (make-instance 'variable :data (mgl-mat:make-mat '(1 1)
							   :initial-element 0.5)))
       (a (call af x))
       (b (call bf a))
       (y (call cf b)))
  (slot-value y 'data))


(let* ((af (make-instance 'square))
       (bf (make-instance 'exp))
       (cf (make-instance 'square))
       (x (make-instance 'variable :data (mgl-mat:make-mat '(1 1)
							   :initial-element 0.5)))
       (a (call af x))
       (b (call bf a))
       (y (call cf b)))
  (setf (slot-value y 'grad) (mgl-mat:make-mat '(1 1)
					       :initial-element 1.0))
  (backward y)
  (slot-value x 'grad))

(let* ((af (make-instance 'square))
       (bf (make-instance 'exp))
       (cf (make-instance 'square))
       (x (make-instance 'variable :data (mgl-mat:make-mat '(1 1)
							   :initial-element 0.5)))
       (a (call af x))
       (b (call bf a))
       (y (call cf b)))
  (setf (slot-value y 'grad) (mgl-mat:make-mat '(1 1)
					       :initial-element 1.0))
  (setf (slot-value b 'grad) (backward cf (slot-value y 'grad)))
  ;(format t "~a~%" (slot-value b 'grad))
  (setf (slot-value a 'grad) (backward bf (slot-value b 'grad)))
  ;(format t "~a~%" (slot-value a 'grad))
  (setf (slot-value x 'grad) (backward af (slot-value a 'grad)))
  ;(format t "~a~%" (slot-value x 'grad))
  (slot-value x 'grad))

(let* ((af (make-instance 'square))
       (bf (make-instance 'exp))
       (cf (make-instance 'square))
       (x (make-instance 'variable :data (mgl-mat:make-mat '(1 1)
							   :initial-element 0.5)))
       (a (call af x))
       (b (call bf a))
       (y (call cf b)))
  (setf (slot-value y 'grad)
	(mgl-mat:make-mat '(1 1)
			  :initial-element 1.0))
  (backward y)
  (slot-value x 'grad))

(let* ((x (make-variable
	   (make-scalar 0.5)))
       (y (square (exp (square x)))))
  (setf (slot-value y 'grad)
	(make-scalar 1.0))
  (backward y)
  (slot-value x 'grad))

(let* ((x (make-variable
	   (make-scalar 0.5)))
       (y (square (exp (square x)))))
  (backward y)
  (slot-value x 'grad))
